[![Build Status](https://travis-ci.org/Grishberg/delegateadapter.svg?branch=master)](https://travis-ci.org/Grishberg/delegateadapter)


## Sample of Clean Architecture for Android.

После прочтения книги Роберта Мартина "Clean Architecture" я негодовал от того, что книга не просто
не ответила на все мои вопросы по чистой архитектуре, но и породила еще больше.
### Основная проблема Clean Architecture от дяди Боба
Меня беспокоил раздел (https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html "What data crosses the boundaries")
где говорится о передачи между слоями данных в виде простой структуры данных (Data Transfer Object).
Но ведь это полное противоречие одному из принципов ООП - инкапсуляция! По принципам ООП должен
передаваться некоторый объект, этот объект инкапсулирует в себе какую то работу с данными.

Если нужно передать из Domain слоя некоторый заголовок бегущей строки, то нужно передать объект - абстракцию
этого заголовка. Для того чтоб отрисовать этот заголовок - не нужно делать геттер `String getTitle()` -
это нарушит инкапсуляцию, лучше сделать метод вроде `void render(RunningLineRenderer renderer)`
с помощью которого будет отрисовываться заголовок, при этом не понадобится никаких геттеров.
Eсли вместе с заголовком у нас должен будет отображаться иконка, то просто дорабатываем метод render,
a Domain слой ничего не узнает об изменениях.

В предлагаемом мной решении в угоду универсальности и инкапсуляции пришлось пожертвовать небольшим
бойлерплейтом и сделать Generic-сущности, каждая типизирована со своим Renderer, который будет рендерить
данную сущность. Имплементация сущности дергает нужные методы у Renderer, например:
```
 renderer.showTitle(title)
 renderer.showDescription(description)
```
Конкретная реализация сущности находится в Presentation слое.
Сущности создаются в Gateway слое с помощью фабрики, конкретная реализация фабрики находится тоже в
Presentation слое. А вот интерфейсы фабрики и всех Renderer-ов - в Domain слое, по прежнему соблюдается
Dependency-Rule дяди Боба и можно легко использовать jar с domain слоем в консольном или десктопном
приложении с другой реализацией renderer-ов и отображаемых сущностей.

И еще небольшой недостаток подхода с `render(SomeRenderer renderer)` :
Если необходимо сделать враппер для сущности, как сделано в данном примере, то для отрисовки приходится
использовать renderer-adapter который позволяет с помощью renderer-A отрисовывать сущность, которая
заточена на использование renderer-B.

## Тестовый проект.
Приложение отображает горизонтальный и вертикальный список карточек, которые запрашиваются из разных
источников, но в горизонтальном списке должны отобржаться какие то карточки из вертикального списка тоже.
Для отображение вертикальной карточки в горизонтали используется вышеупомянутый адаптер: `NewsToTeasersRendererAdapter`
Код, который отвечает за отображение вертикальных и горизонтальных карточек находится в соответсвующих модулях

### Структура проекта.
- __app__ - основной модуль приложение где все собирается воедино.
- __detailed_info__ - интерфейс сущности для отображения детальной информации после клика на карточку
- __feature_content__ - интерфейсы domain слоя для отображения детальной информации после клика на карточку
- __feature_content_domain__ - domain слой с пользовательскими сценариями отображения детальной информации выбранной карточки,
тут же содержится gateway слой для получения детальной информации по выбранной карточке.
- __feature_content_ui__ - presentation слой детальной информации о выбранной карточке
- __feature_vertical_feeds__ - интерфейсы, используемые для вертикальных карточек, выделены в отдельный модуль
для возможности параллельной сборки feature_horizontal_feed_domain и используемого в нем feature_vertical_feeds_domain
- __feature_vertical_feeds_domain__ - бизнес логика вертикальных карточек, модуль содержит gateway слой,
это сделано намеренно чтоб исключить возможность инжектить с помощью DI репозиторий карточек и использовать
там где нужно, дядя Боб рекомендует так сделать, чтоб не было соблазна в presentation слое обратиться напрямую к gateway, минуя domain.
на самом деле domain слой понятия не имеет что это именно вертикальные карточки, название vertical
выборано для удобной навигации по проекту.
- __feature_vertical_feeds_ui__ -  presentation слой для отображения вертикальных карточек, тут происходит
из отрисовка в виде вертикального `RecyclerView`
- __feature_horizontal_feed_domain__ - domain слой для горизонтальных карточек, зависит от __feature_vertical_feeds__,
но не зависит от __feature_vertical_feeds_domain__ чтоб эти модули могли собираться параллельно.
- __feature_horizontal_feed_ui__ представление для горизонтальных карточек, тут содержится вышеупомянутый NewsToTeasersRendererAdapter
- __delegateadapter__ - еще одна простая реализация паттерна delegate adapter.

### Особенности и сложности во время реализации.
Было сложно сходу сделать получение детальной информации по клику на карточку, я привык мыслить
подходом из структурного программирования:
- по клику на карточку беру из модели данных карточки некоторые поля для отображения "быстрой" детальной информации
- беру из модели карточки ID чтоб сделать запрос в базу данных.

Но чтоб прекратить насиловать инкапсуляцию и остановить знание о внутренностях абстракции карточки,
я создал в отдельном модуле __detailed_info__ абстракцию детальной информации и разместил рядом
интерфейс `DetailedInfoRenderer`. Каждый модуль карточек зависит от модуля с детальной информацией,
в интерфейсе сущности каждой карточки добавил метод, который возвращает реализацию `DetailedInfo` - она
используется для предварительного детального отображение информации по карточке.

Для запроса подробной информации пришлось добавить в сущность карточек метод `requestDetailedInfo`,
который принимает на вход делегат, с помощью которого будет начинаться загрузка данных из сети или бд.
Конкретная реализация карточки знает что передать такому делегату - id, или имя файла, или ссылку,
по которой будут запрашиваться данные. Но никакого геттера при этом у сущности не будет!

В данном примере предполагается что данный метод будет вызывать gateway слой экрана детальной информации,
который находится в __feature_content_domain__ ( из соображения сокрытия прямого вызова методов gateway вне
domain слоя)